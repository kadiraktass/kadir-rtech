#include "ros/ros.h"
#include <moveit/move_group_interface/move_group.h>
#include <moveit/planning_scene_interface/planning_scene_interface.h>
#include <moveit_msgs/DisplayTrajectory.h>




int main(int argc, char **argv)
{

ros::init(argc, argv, "planning_tutorial_node");
 
ros::NodeHandle n;

ros::AsyncSpinner spinner(1);
spinner.start();
moveit::planning_interface::MoveGroup group("right_arm");
moveit::planning_interface::PlanningSceneInterface planning_scene_interface;
moveit_msgs::DisplayTrajectory display_trajectory;
moveit::planning_interface::MoveGroup::Plan my_plan;

const robot_state::JointModelGroup *joint_model_group =
group.getCurrentState()->getJointModelGroup("right_arm");

geometry_msgs::Pose target_pose1;
target_pose1.orientation.w =1.0;
target_pose1.position.x =   0.28;
target_pose1.position.y =   -0.7;
target_pose1.position.z =   1.0;
group.setPoseTarget(target_pose1);

//robot_state::RobotState start_state(*group.getCurrentState());
//geometry_msgs::Pose start_pose2;
//start_pose2.orientation.w = 1.0;
//start_pose2.position.x = 0.55;
//start_pose2.position.y = -0.05;
//start_pose2.position.z = 0.8;
//const robot_state::JointModelGroup *joint_model_group =
//                start_state.getJointModelGroup(group.getName());
//start_state.setFromIK(joint_model_group, start_pose2);
//group.setStartState(start_state);


//std::vector<geometry_msgs::Pose> waypoints;

//geometry_msgs::Pose target_pose3 = start_pose2;
//target_pose3.position.x += 0.2;
//target_pose3.position.z += 0.2;
//waypoints.push_back(target_pose3);  // up and out

//target_pose3.position.y -= 0.2;
//waypoints.push_back(target_pose3);  // left

//target_pose3.position.z -= 0.2;
//target_pose3.position.y += 0.2;
//target_pose3.position.x -= 0.2;
//waypoints.push_back(target_pose3);  // down and right (back to start)

//moveit_msgs::RobotTrajectory trajectory;
//double fraction = group.computeCartesianPath(waypoints,
//                                             0.01,  // eef_step
//                                             0.0,   // jump_threshold
//                                             trajectory);


group.setPlanningTime(10.0);

group.plan(my_plan);


  return 0;
}












